hier is een voorbeeld van een functie met een case matching:

f (a) {
match g(a) with
 | (0,0) -> return 3;
 | (fac(c),0) -> if b then c = 1 + c; return c;
 | (d,0) -> return d;
 | _ -> return snd a;;
 }

merk op dat bij een functionele taal na de pijl een expressie zou staan wat de nieuwe a zou worden.
Hier staat na de pijl een rijtje statements die uitgevoerd wordt.
merk op dat de match casing eindigt met 2 puntkomma's. 
Een om het rijtje stmts af te sluiten, een om de match casing af te sluiten.
merk op dat de functie g blijkbaar een tupel van ints teruggeeft.
De functie f geeft een int terug.

Stel c bestaat al, dan wordt gewoon de waarde van fac(c) uitgerekend.
Stel c bestaat niet, dan is dit illegale syntax, want dan kunnen we fac(c) niet uitrekenen.
stel d bestaat al, dan wordt gewoon de tupel (d,0) gegeven voor matching
stel d bestaat niet, dan wordt gekeken of g(a) match met de vorm (_,0). 
Zoja, dan geven we d de waarde die _ had in de stmts na de pijl. 
Dit is een vorm van een zeer locale variabele. d bestaat niet buiten deze stmts.

in toplevel mag je nu typedecls doen.
Voorbeelden van een typedecl is:

type stringwithlength = ([char],int)
type intorchar = Int of int | Char of char
type geslacht = Man | Vrouw | Anders of [Char]
type hands = Lefthand | Righthand

Inttype, Man etc worden constructors genoemd.
constructors moeten met een hoofdletter beginnen.
vars en types moeten met een kleine letter beginnen.
Dit was eerst niet, eerst waren de types 'int', 'bool' en 'char' met een hoofdletter

wil je bijvoorbeeld een intorchar aanmaken, dan doe je dat als volgt:
vardecl: intorchar a = Int 2;
stmt: a = Int 2;

Verder heb je ook nog records:

type person = 
{
 name: [char];
 age: int;
 friends: [person];
}

name, age en friends worden fields genoemd.
als a is een person, dan verkrijg je zijn naam met:

a.name

maar op het moment ga ik alleen match casing en types van de vorm stringwithlength en hands toevoegen
records en constructors met argumenten nog niet.